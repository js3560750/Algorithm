package com.js.sort;

import java.util.Arrays;

import javax.annotation.processing.Messager;

/*
 * 有序数组合并练习
 * 
 * 有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。
 * 给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组
 * 
 * 
 */
public class Exercise_OrderedArrayMerge {

	public static void main(String[] args) {
		
		int[] A={47128,63739,81503,92947,98169,99774,108082,110040,111290,112530,129271,146949,157702,161189,173696,174091,256783,270452,275353,284662,296558,322600,349757,387441,394743,394957,413039,419448,423240,425135,427500,
				471774,489570,497159,533609,543290,567642,576943,585021,587546,605202,611531,613983,630482,643476,655483,673826,683589,686493,686550,687358,708460,709115,724530,769851,781840,784356,793345,801417,812719,819119,844855,
				853893,878121,918212,922503,929192,959600,965781,988040,1013583,1042549,1068083,1081502,1117601,1138646,1150571,1150914,1195741,1209896,1226440,1305000,1315147,1321842,1321890,1403269,1410747,1413976,1439365,1474259,1479449,
				1487793,1505507,1526625,1528265,1535091,1537397,1544010,1546295,1560932,1611780,1668805,1701711,1703701,1712588,1725722,1747001,1753403,1761258,1761534,1781229,1822007,1822697,1841248,1844715,1871493,1875047,1923360,1931471,
				1940206,1953842,1957217,1966676,2001138,2028258,2032433,2043722,2061237,2080031,2092637,2110851,2127164,2127894,2136225,2149547,2177754,2209752,2218566,2226213,2241228,2247200,2298714,2303245,2325068,2384830,2403139,2420218,
				2438590,2443200,2463916,2471354,2483920,2507700,2523751,2524292,2560469,2560480,2566170,2571308,2583990,2614297,2620383,2630109,2673150,2673670,2676552,2684030,2694572,2726369,2741705,2750694,2755727,2844357,2871374,2873370,
				2875924,2894422,2908344,2929349,2929852,2932916,2936153,2938289,2954097,2964385,2970719,3005284,3014121,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
		
		int[] B={144712,179444,185396,199706,224065,268779,359995,438122,470680,477425,521423,549255,648769,721107,723239,789006,888120,1104989,1402820,1529676,1591639,1701017,1820501,1829548,1865618,1883237,1904821,
				2045735,2053432,2086795,2098654,2129323,2129594,2175869,2176643,2206950,2235965,2539717,2643472,2673728,2781156,2867444,2892817,2986434};
		
		int n=A.length;
		int m=B.length;
		
		System.out.println(Arrays.toString(mergeAB(A,B,n,m)));

	}

	/**
	 * 思路是A中最后一个非0元素和B中最后一个元素进行比较，大的放在A最后一位，然后剩下的和另一组脚标index-1的元素进行比较，大的放在A倒数第二位，
	 * 如上循环直到A或者B的元素全部比较完，如果A剩余，则不用赋值直接返回，如果B剩余，则把B的剩余元素赋给对应脚标的A并返回。
	 * 
	 * 重要：！！！下面是此题关键！！！
	 * indexA=0之后依然会进行一轮比较，比较完之后indexA=-1，这就说明A的元素已经比较完了，要跳出while循环，进行赋值操作。B同理
	 * 
	 * @param A
	 * @param B
	 * @param n
	 * @param m
	 * @return
	 */
	private static int[] mergeAB(int[] A,int[] B,int n,int m){
		//先确定两个移动的比较脚标
		int indexA=n-m-1;
		int indexB=m-1;
		//存入的指定脚标
		int index=n-1;
		
		//依次根据脚标比较
		//这里要注意的是，当脚标indexA=0，即A已经读到最小的元素了，B还没有读完，比较之后indexA=-1，若再进行循环则脚标越界
		//因此indexA=0作为最后一轮比较，这之后B[indexB]之前的所有元素直接覆盖到A，返回A就是最终结果
		//indexB=0同理
		while(index>0&&indexA>=0&&indexB>=0){
			if(A[indexA]>B[indexB]){
				A[index]=A[indexA];
				index--;
				indexA--;
			}else{
				A[index]=B[indexB];
				index--;
				indexB--;
			}
		}
		
		//当indexA==-1了，即A中元素都已经比较完了，A最小的都比B中某一元素大
		//那么把剩余B的直接赋给A就行了
		if(indexA==-1){
			for(int i=indexB;i>=0;i--){
				A[i]=B[i];
			}
		}
		
		//不用算indexB==-1，因为indexB=-1则A剩余元素都比B最小的元素还小，保持不变输出就行了

		
		return A;
	}
}

